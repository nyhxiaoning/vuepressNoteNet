![成长](/images/home.png)
[[toc]]


## 回到博客主页
[博客首页](./../README.md)  


### 001.vue3中使用jsx和tsx的方式写组件
在 setup 中通过函数返回，要不就在 render 函数中实现
#### 案例1
~~~
const  Foo = {
    setup（）{
        const count = ref(0);
        //// 返回一个函数
    // 如果是返回一个对象的话，这个对象其实可以看做 view 和 model 之间的接口层，但是返回一个函数的话，就破坏了
    // 必须对 ref 类型的响应式对象使用 .value
        return ()=>{
            <div>{count.value}</div>
        }
    }
}



在 setup 中直接返回的话，其实是破坏了 setup 返回对象作为 view 和 model 层的接口，而且如果是 ref 类型的响应式对象的话，你还必须使用 .value ,享受不到结构 ref 了。你会发现你的代码可读性极差
~~~

案例2
~~~
// render 中实现
const Foo = {
   setup(){
    const count = ref(0) 
    return {count}
   },
   render(ctx){
     // 必须调用 ctx
     return <div>{ctx.count}</div>
   }
}


~~~


总结
~~~

对于我来讲 可读性大于灵活性

而且 templete 会享受到所有的编译优化

不管是从可读性上还是性能上我都推荐优先使用 templete 。

当逻辑必须要用 jsx/tsx 来实现的话再上。
（JSX 的表达能力比 template 更强。
JSX 表达能力的上限是 JS 语言本身，而 template 表达能力的上限是 Vue 的各种指令如 v-if v-for v-bind ）

~~~

#### 两个vue3组件场景使用jsx更佳
~~~
场景1
根据 props 上的 reverse 属性，来决定是否要调换两块内容的渲染顺序
const renderContent = () => {
  const Content = [
    <div class="foo">Foo DOM...</div>,
    <div class="bar">Bar DOM...</div>,
  ];
  if (props.reverse) {
    Content.reverse();
  }
  return <div>{Content}</div>;
}

//通过模板实现
<template>
  <div>
    <template v-if="reverse">
      <div class="bar">Bar DOM...</div>
      <div class="foo">Foo DOM...</div>
    </template>
    <template v-else>
      <div class="foo">Foo DOM...</div>
      <div class="bar">Bar DOM...</div>
    </template>
  </div>
</template>

场景2
如果做一个table组件，支持cell自定义
<MyTable cellRender={(data)=><strong>{data.icon} {data.text}</strong>}

如果需要template的话，只能通过slot,在slot里面使用中间变量。
<template>
    <table class="jeremy-table" :bordered="bordered">
        <slot></slot>
    </table>
</template>

然后倒入后
<nyh-table>
    <template v-slot="header">
        <span>快速排序算法</span>
    </template>
</nyh-table>




~~~