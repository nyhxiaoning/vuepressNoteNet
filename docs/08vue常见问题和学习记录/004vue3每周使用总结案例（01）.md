![成长](/images/home.png)
[[toc]]


## 回到博客主页
[博客首页](./../README.md)  

- 第一类：基础API类的不熟悉问题

- 第二类：样式类

- 高级API使用使用

- 框架之间结合使用问题



## API类的不熟悉问题


## 记录组内常见vue问题


### 001vue中自定义v-model使用
本质上还是通过 自定义标签的 attribute 传递和接受；
~~~
在自定义标签中注册 v-model:attriButeName="value" , 会拆分为两个属性

:attributeName="value" 和 @update:attributeName="value=$event" ；

~~~


~~~

---父组件绑定
<my-comp v-model:name="nameValue" v-model:age="ageValue" />
注意如果v-model没有指定，那么会用默认的modelValue替代，等同一下


---子组件中使用：
export default {
    // props 注册接受 自定义标签的 name和age 
    props:['name', 'age'],
    // emits 注册 接受自定义标签的 update:name 和 update:age 属性绑定的事件
    emits: ['update:name', 'update:age'],
    setup(context){
        setTimeout(() => {
          // 通过 $emit 触发事件传递数据
          context.emit('update:name', 'new-name');
          context.emit('update:age', 100)
        })
    }
}

~~~



### computed的经典使用场景。
/-------------当赋值给计算属性的时候，将调用setter函数。
多用于在模板组件中需要修改计算属性自身的值的时候。-----------------/

computed的属性可以被视为是data一样，可以读取和设值。
一般使用：
都是return返回值。


watch和computed对比使用场景：一个值变化了，通知监听触发

子组件中v-model的创建自定义的属性变化，变化之后，需要做一个监听通知。

简单不用watch的办法是通过computed方法，将set和get方法放入，然后set中进行通知。

~~~
computed: {
    updateMessage: {
      get: function() {
        console.log('计算属性', this.message)
        return this.message
      },
      set: function(newVal) {
        this.message = newVal
        console.log('newVal', newVal)
      }
    }
  },
  mounted () {
    //计算属性变化了
    updateMessage = '222'
    console.log('测试：', this)
   },
~~~

### watch和computed使用场景区分

~~~
--- computed是根据当前值或是多个值，计算新的值的时候，使用（如果vue3使用，需要单独导出，或是在reactive中。）
--- watch是监听一个值变化的时候，通知或是处理其他事情
~~~



### 使用popover使用js控制弹出编程
~~~

// 当前的popover的ref
const popoverRef = ref();
//使用unref原因，如果参数是一个 ref，则返回内部值，否则返回参数本身。
/**
 * 命令触发popover弹出界面
 */
const onClickOutside = () => {
  // unref(popoverRef).popperRef?.delayHide?.();
  // casterSelectTableFn();
  unref(popoverRef).popperRef?.delayHide?.();
};


~~~